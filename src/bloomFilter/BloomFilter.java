/**
 * 
 */
package bloomFilter;

/**
 * @author salipuri
 * 
 * A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. 
 * For example, checking availability of username is set membership problem, where the set is the list of all registered username. 
 * The price we pay for efficiency is that it is probabilistic in nature that means, there might be some False Positive results. 
 * False positive means, it might tell that given username is already taken but actually it’s not.
 * 
Interesting Properties of Bloom Filters
* Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements.
* Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
* Bloom filters never generate false negative result, i.e., telling you that a username doesn’t exist when it actually exists.
* Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements. 
* Example – if we delete “geeks” (in given example below) by clearing bit at 1, 4 and 7, we might end up deleting “nerd” also 
* Because bit at index 4 becomes 0 and bloom filter claims that “nerd” is not present.
*
* 
* Applications of Bloom filters
* Medium uses bloom filters for recommending post to users by filtering post which have been seen by user.
* Quora implemented a shared bloom filter in the feed backend to filter out stories that people have seen before.
* The Google Chrome web browser used to use a Bloom filter to identify malicious URLs
* Google BigTable, Apache HBase and Apache Cassandra, and Postgresql use Bloom filters to reduce the disk lookups for non-existent rows or columns
 */
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Stream;

public class BloomFilter {

    final static int NUMBER_OF_BITS = 6400;

    final static HashFunction h1 = new HashFunction(11, 9);
    final static HashFunction h2 = new HashFunction(17, 15);
    final static HashFunction h3 = new HashFunction(31, 29);
    final static HashFunction h4 = new HashFunction(61, 59);

    public static void main(String[] args) throws ClassNotFoundException {

        // Bit array of size 6400 bits (80 bytes)
        BitSet bitSet = new BitSet(NUMBER_OF_BITS);

        // Read the words into an array (4000 words)
        List<String> dictionary = new ArrayList<>();
        URL fileName = BloomFilter.class.getResource("dictionary.txt");

        //read file into stream, try-with-resources
        try (Stream<String> stream = Files.lines(Paths.get(fileName.getFile()))) {
            stream.forEach(word -> dictionary.add(word));
        } catch (IOException e) {
            e.printStackTrace();
        }

        List<String> randomWordList = new ArrayList<>();

        // Prepare the bloom filter with random words from wordList, and add in randomWordList.
        for (int i = 0; i < 1000; i++) {

            final int randomNumber = ThreadLocalRandom.current().nextInt(dictionary.size() - 1);
            final String randomWord = dictionary.get(randomNumber);

            // Populate bloom filter
            bitSet.set(h1.getHashValue(randomWord));
            bitSet.set(h2.getHashValue(randomWord));
            bitSet.set(h3.getHashValue(randomWord));
            bitSet.set(h4.getHashValue(randomWord));

            randomWordList.add(randomWord);
        }


        for (int i = 0; i < 4000; i++) {
            final String word = dictionary.get(i);
            final boolean answerFromBloomFilter = (bitSet.get(h1.getHashValue(word)) && bitSet.get(h2.getHashValue(word))
                    && bitSet.get(h3.getHashValue(word)) && bitSet.get(h4.getHashValue(word)));

            System.out.println("-------------------------------------------------------------------------------------------------------- ");
            System.out.println("Check if the Word [" + word  + "] is present in Bloom Filter");
            System.out.println("ANSWER from bloom filter : [" + answerFromBloomFilter + "]");

            if (answerFromBloomFilter) {
                System.out.println("Actual Answer with less (< 100%) Probability : [" + randomWordList.contains(word) + "]");
            } else {
                System.out.println("Actual Answer will be FALSE with 100 % Probability : [" + randomWordList.contains(word) + "]");
            }

            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    private static class HashFunction {

        private long prime;
        private long odd;

        public HashFunction(final long prime, final long odd) {
            this.prime = prime;
            this.odd = odd;
        }

        public int getHashValue(final String word) {
            int hash = word.hashCode();
            if (hash < 0) {
                hash = Math.abs(hash);
            }
            return calculateHash(hash, prime, odd);
        }

        private int calculateHash(final int hash, final long prime, final long odd) {
            return (int)((((hash % NUMBER_OF_BITS) * prime) % NUMBER_OF_BITS) * odd) % NUMBER_OF_BITS;
        }

    }

}

